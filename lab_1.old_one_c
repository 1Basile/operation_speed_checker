#include<stdio.h>
#include <sys/time.h>
#include <time.h>
/* #include "checkers.h" */

long double division_for_float(float *massive, unsigned interation_number)
{
    float a1 = massive[0];
    float a2 = massive[1];
    float a3 = massive[2];
    float a4 = massive[3];
    float a5 = massive[4];
    float a6 = massive[5];
    float a7 = massive[6];
    float a8 = massive[7];
    float a9 = massive[8];
    float a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 / a3;
        a2 = a3 / a4;
        a3 = a4 / a5;
        a4 = a5 / a6;
        a5 = a6 / a7;
        a6 = a7 / a8;
        a7 = a8 / a9;
        a8 = a9 / a10;
        a9 = a10 / a1;
        a10 = a1 / a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* float time_spent = (float)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double elapsed = seconds + microseconds*1e-6;

    long double operations_per_sec = (long double)(1/(long double)elapsed * interation_number * 10);
    return operations_per_sec ;
}

long double substaction_for_float(float *massive, unsigned interation_number)
{
    float a1 = massive[0];
    float a2 = massive[1];
    float a3 = massive[2];
    float a4 = massive[3];
    float a5 = massive[4];
    float a6 = massive[5];
    float a7 = massive[6];
    float a8 = massive[7];
    float a9 = massive[8];
    float a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 - a3;
        a2 = a3 - a4;
        a3 = a4 - a5;
        a4 = a5 - a6;
        a5 = a6 - a7;
        a6 = a7 - a8;
        a7 = a8 - a9;
        a8 = a9 - a10;
        a9 = a10 - a1;
        a10 = a1 - a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* float time_spent = (float)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */

    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double elapsed = seconds + microseconds*1e-6;

   long double operations_per_sec = 1/(long double)elapsed * interation_number * 10;
    return operations_per_sec;
}

long double adding_for_float(float *massive, unsigned interation_number)
{
    float a1 = massive[0];
    float a2 = massive[1];
    float a3 = massive[2];
    float a4 = massive[3];
    float a5 = massive[4];
    float a6 = massive[5];
    float a7 = massive[6];
    float a8 = massive[7];
    float a9 = massive[8];
    float a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 + a3;
        a2 = a3 + a4;
        a3 = a4 + a5;
        a4 = a5 + a6;
        a5 = a6 + a7;
        a6 = a7 + a8;
        a7 = a8 + a9;
        a8 = a9 + a10;
        a9 = a10 + a1;
        a10 = a1 + a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* float time_spent = (float)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */

    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double elapsed = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)elapsed * interation_number * 10;
    return operations_per_sec;
}

long double multiplying_for_float(float *massive, unsigned interation_number)
{
    float a1 = massive[0];
    float a2 = massive[1];
    float a3 = massive[2];
    float a4 = massive[3];
    float a5 = massive[4];
    float a6 = massive[5];
    float a7 = massive[6];
    float a8 = massive[7];
    float a9 = massive[8];
    float a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 * a3;
        a2 = a3 * a4;
        a3 = a4 * a5;
        a4 = a5 * a6;
        a5 = a6 * a7;
        a6 = a7 * a8;
        a7 = a8 * a9;
        a8 = a9 * a10;
        a9 = a10 * a1;
        a10 = a1 * a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* float time_spent = (float)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
 
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double elapsed = seconds + microseconds*1e-6;

   long double operations_per_sec = 1/(long double)elapsed * interation_number * 10;
    return operations_per_sec;
}

long double division_for_long(long *massive, unsigned interation_number)
{
    struct timeval start, end, empty_loop_start, empty_loop_end;
    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        long a1 = massive[0];
        long a2 = massive[1];
        long a3 = massive[2];
        long a4 = massive[3];
        long a5 = massive[4];
        long a6 = massive[5];
        long a7 = massive[6];
        long a8 = massive[7];
        long a9 = massive[8];
        long a10 = massive[9];

        a1 = a2 / a3;
        a2 = a3 / a4;
        a3 = a4 / a5;
        a4 = a5 / a6;
        a5 = a6 / a7;
        a6 = a7 / a8;
        a7 = a8 / a9;
        a8 = a9 / a10;

        a1 = massive[0];
        a2 = massive[1];

        a9 = a10 / a1;
        a10 = a1 / a2;
    }

    gettimeofday(&end, 0);
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) 
    {
      long a1 = massive[0];
      long a2 = massive[1];
      long a3 = massive[2];
      long a4 = massive[3];
      long a5 = massive[4];
      long a6 = massive[5];
      long a7 = massive[6];
      long a8 = massive[7];
      long a9 = massive[8];
      long a10 = massive[9];
 
      a1 = massive[0];
      a2 = massive[1];

   } 
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
  
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double elapsed = seconds + microseconds*1e-6;

    long double operations_per_sec = (long double)(1/(long double)elapsed * interation_number * 10);
    return operations_per_sec;
}

long double substaction_for_long(long *massive, unsigned interation_number)
{
    long a1 = massive[0];
    long a2 = massive[1];
    long a3 = massive[2];
    long a4 = massive[3];
    long a5 = massive[4];
    long a6 = massive[5];
    long a7 = massive[6];
    long a8 = massive[7];
    long a9 = massive[8];
    long a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 - a3;
        a2 = a3 - a4;
        a3 = a4 - a5;
        a4 = a5 - a6;
        a5 = a6 - a7;
        a6 = a7 - a8;
        a7 = a8 - a9;
        a8 = a9 - a10;
        a9 = a10 - a1;
        a10 = a1 - a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
   
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    double long operations_per_sec = 1/(double long)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double adding_for_long(long *massive, unsigned interation_number)
{
    long a1 = massive[0];
    long a2 = massive[1];
    long a3 = massive[2];
    long a4 = massive[3];
    long a5 = massive[4];
    long a6 = massive[5];
    long a7 = massive[6];
    long a8 = massive[7];
    long a9 = massive[8];
    long a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 + a3;
        a2 = a3 + a4;
        a3 = a4 + a5;
        a4 = a5 + a6;
        a5 = a6 + a7;
        a6 = a7 + a8;
        a7 = a8 + a9;
        a8 = a9 + a10;
        a9 = a10 + a1;
        a10 = a1 + a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double multiplying_for_long(long *massive, unsigned interation_number)
{
    long a1 = massive[0];
    long a2 = massive[1];
    long a3 = massive[2];
    long a4 = massive[3];
    long a5 = massive[4];
    long a6 = massive[5];
    long a7 = massive[6];
    long a8 = massive[7];
    long a9 = massive[8];
    long a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 * a3;
        a2 = a3 * a4;
        a3 = a4 * a5;
        a4 = a5 * a6;
        a5 = a6 * a7;
        a6 = a7 * a8;
        a7 = a8 * a9;
        a8 = a9 * a10;
        a9 = a10 * a1;
        a10 = a1 * a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
     
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

   long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}


long double division_for_int(int *massive, unsigned interation_number)
{
   struct timeval start, end, empty_loop_start, empty_loop_end;
   gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        int a1 = massive[0];
        int a2 = massive[1];
        int a3 = massive[2];
        int a4 = massive[3];
        int a5 = massive[4];
        int a6 = massive[5];
        int a7 = massive[6];
        int a8 = massive[7];
        int a9 = massive[8];
        int a10 = massive[9];
 
        a1 = a2 / a3;
        a2 = a3 / a4;
        a3 = a4 / a5;
        a4 = a5 / a6;
        a5 = a6 / a7;
        a6 = a7 / a8;
        a7 = a8 / a9;
        a8 = a9 / a10;

        a1 = massive[0];
        a2 = massive[1];

        a9 = a10 / a1;
        a10 = a1 / a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) 
    {
        int a1 = massive[0];
        int a2 = massive[1];
        int a3 = massive[2];
        int a4 = massive[3];
        int a5 = massive[4];
        int a6 = massive[5];
        int a7 = massive[6];
        int a8 = massive[7];
        int a9 = massive[8];
        int a10 = massive[9];
 
        a1 = massive[0];
        a2 = massive[1];

   }
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
      
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

  long double operations_per_sec = (long double)(1/(long double)time_spent * interation_number * 10);
    return operations_per_sec;
}

long double substaction_for_int(int *massive, unsigned interation_number)
{
    int a1 = massive[0];
    int a2 = massive[1];
    int a3 = massive[2];
    int a4 = massive[3];
    int a5 = massive[4];
    int a6 = massive[5];
    int a7 = massive[6];
    int a8 = massive[7];
    int a9 = massive[8];
    int a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 - a3;
        a2 = a3 - a4;
        a3 = a4 - a5;
        a4 = a5 - a6;
        a5 = a6 - a7;
        a6 = a7 - a8;
        a7 = a8 - a9;
        a8 = a9 - a10;
        a9 = a10 - a1;
        a10 = a1 - a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
       
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

 double long operations_per_sec = 1/(double long)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double adding_for_int(int *massive, unsigned interation_number)
{
    int a1 = massive[0];
    int a2 = massive[1];
    int a3 = massive[2];
    int a4 = massive[3];
    int a5 = massive[4];
    int a6 = massive[5];
    int a7 = massive[6];
    int a8 = massive[7];
    int a9 = massive[8];
    int a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 + a3;
        a2 = a3 + a4;
        a3 = a4 + a5;
        a4 = a5 + a6;
        a5 = a6 + a7;
        a6 = a7 + a8;
        a7 = a8 + a9;
        a8 = a9 + a10;
        a9 = a10 + a1;
        a10 = a1 + a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double multiplying_for_int(int *massive, unsigned interation_number)
{
    int a1 = massive[0];
    int a2 = massive[1];
    int a3 = massive[2];
    int a4 = massive[3];
    int a5 = massive[4];
    int a6 = massive[5];
    int a7 = massive[6];
    int a8 = massive[7];
    int a9 = massive[8];
    int a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) 
    { 
        a1 = 1;
        a2 = 2;
        a3 = 3;
        a4 = 4;
        a5 = 5;
        a6 = 6;
        a7 = 7;
        a8 = 8;
        a9 = 9;
        a10 = 10;
    }
    gettimeofday(&empty_loop_end, 0);


    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 * a3;
        a2 = a3 * a4;
        a3 = a4 * a5;
        a4 = a5 * a6;
        a5 = a6 * a7;
        a6 = a7 * a8;
        a7 = a8 * a9;
        a8 = a9 * a10;
        a9 = a10 * a1;
        a10 = a1 * a2;
    }

    gettimeofday(&end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double division_for_char(char *massive, unsigned interation_number)
{
   struct timeval start, end, empty_loop_start, empty_loop_end;
   gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        char a1 = massive[0];
        char a2 = massive[1];
        char a3 = massive[2];
        char a4 = massive[3];
        char a5 = massive[4];
        char a6 = massive[5];
        char a7 = massive[6];
        char a8 = massive[7];
        char a9 = massive[8];
        char a10 = massive[9];

        a1 = a2 / a3;
        a2 = a3 / a4;
        a3 = a4 / a5;
        a4 = a5 / a6;
        a5 = a6 / a7;
        a6 = a7 / a8;
        a7 = a8 / a9;
        a8 = a9 / a10;
 
        a1 = massive[0];
        a2 = massive[1];

        a9 = a10 / a1;
        a10 = a1 / a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) 
    {
        char a1 = massive[0];
        char a2 = massive[1];
        char a3 = massive[2];
        char a4 = massive[3];
        char a5 = massive[4];
        char a6 = massive[5];
        char a7 = massive[6];
        char a8 = massive[7];
        char a9 = massive[8];
        char a10 = massive[9];
 
        a1 = massive[0];
        a2 = massive[1];

   }
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = (long double)(1/(long double)time_spent * interation_number * 10);
    return operations_per_sec;
}

long double substaction_for_char(char *massive, unsigned interation_number)
{
    char a1 = massive[0];
    char a2 = massive[1];
    char a3 = massive[2];
    char a4 = massive[3];
    char a5 = massive[4];
    char a6 = massive[5];
    char a7 = massive[6];
    char a8 = massive[7];
    char a9 = massive[8];
    char a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 - a3;
        a2 = a3 - a4;
        a3 = a4 - a5;
        a4 = a5 - a6;
        a5 = a6 - a7;
        a6 = a7 - a8;
        a7 = a8 - a9;
        a8 = a9 - a10;
        a9 = a10 - a1;
        a10 = a1 - a2;
    }


    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    double long operations_per_sec = 1/(double long)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double adding_for_char(char *massive, unsigned interation_number)
{
    char a1 = massive[0];
    char a2 = massive[1];
    char a3 = massive[2];
    char a4 = massive[3];
    char a5 = massive[4];
    char a6 = massive[5];
    char a7 = massive[6];
    char a8 = massive[7];
    char a9 = massive[8];
    char a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 + a3;
        a2 = a3 + a4;
        a3 = a4 + a5;
        a4 = a5 + a6;
        a5 = a6 + a7;
        a6 = a7 + a8;
        a7 = a8 + a9;
        a8 = a9 + a10;
        a9 = a10 + a1;
        a10 = a1 + a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double multiplying_for_char(char *massive, unsigned interation_number)
{
    char a1 = massive[0];
    char a2 = massive[1];
    char a3 = massive[2];
    char a4 = massive[3];
    char a5 = massive[4];
    char a6 = massive[5];
    char a7 = massive[6];
    char a8 = massive[7];
    char a9 = massive[8];
    char a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 * a3;
        a2 = a3 * a4;
        a3 = a4 * a5;
        a4 = a5 * a6;
        a5 = a6 * a7;
        a6 = a7 * a8;
        a7 = a8 * a9;
        a8 = a9 * a10;
        a9 = a10 * a1;
        a10 = a1 * a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}


long double division_for_double(double *massive, unsigned interation_number)
{
    double a1 = massive[0];
    double a2 = massive[1];
    double a3 = massive[2];
    double a4 = massive[3];
    double a5 = massive[4];
    double a6 = massive[5];
    double a7 = massive[6];
    double a8 = massive[7];
    double a9 = massive[8];
    double a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 / a3;
        a2 = a3 / a4;
        a3 = a4 / a5;
        a4 = a5 / a6;
        a5 = a6 / a7;
        a6 = a7 / a8;
        a7 = a8 / a9;
        a8 = a9 / a10;
        a9 = a10 / a1;
        a10 = a1 / a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = (long double)(1/(long double)time_spent * interation_number * 10);
    return operations_per_sec;
}

long double substaction_for_double(double *massive, unsigned interation_number)
{
    double a1 = massive[0];
    double a2 = massive[1];
    double a3 = massive[2];
    double a4 = massive[3];
    double a5 = massive[4];
    double a6 = massive[5];
    double a7 = massive[6];
    double a8 = massive[7];
    double a9 = massive[8];
    double a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 - a3;
        a2 = a3 - a4;
        a3 = a4 - a5;
        a4 = a5 - a6;
        a5 = a6 - a7;
        a6 = a7 - a8;
        a7 = a8 - a9;
        a8 = a9 - a10;
        a9 = a10 - a1;
        a10 = a1 - a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double adding_for_double(double *massive, unsigned interation_number)
{
    double a1 = massive[0];
    double a2 = massive[1];
    double a3 = massive[2];
    double a4 = massive[3];
    double a5 = massive[4];
    double a6 = massive[5];
    double a7 = massive[6];
    double a8 = massive[7];
    double a9 = massive[8];
    double a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 + a3;
        a2 = a3 + a4;
        a3 = a4 + a5;
        a4 = a5 + a6;
        a5 = a6 + a7;
        a6 = a7 + a8;
        a7 = a8 + a9;
        a8 = a9 + a10;
        a9 = a10 + a1;
        a10 = a1 + a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}

long double multiplying_for_double(double *massive, unsigned interation_number)
{
    double a1 = massive[0];
    double a2 = massive[1];
    double a3 = massive[2];
    double a4 = massive[3];
    double a5 = massive[4];
    double a6 = massive[5];
    double a7 = massive[6];
    double a8 = massive[7];
    double a9 = massive[8];
    double a10 = massive[9];
    struct timeval start, end, empty_loop_start, empty_loop_end;

    gettimeofday(&start, 0);
    // Taking time passed after this loop finish working 
    for (int i = 0; i < interation_number; i++)
    {
        a1 = a2 * a3;
        a2 = a3 * a4;
        a3 = a4 * a5;
        a4 = a5 * a6;
        a5 = a6 * a7;
        a6 = a7 * a8;
        a7 = a8 * a9;
        a8 = a9 * a10;
        a9 = a10 * a1;
        a10 = a1 * a2;
    }

    gettimeofday(&end, 0);
    
    // Measuring time needed for bare loop finishs
    gettimeofday(&empty_loop_start, 0);
    for (int i = 0; i < interation_number; i++) {}
    gettimeofday(&empty_loop_end, 0);

    /* double time_spent = (double)(end_tick - start_tick - (empty_loop_ends_tick - empty_loop_start_tick)) / CLOCKS_PER_SEC; */
    
    long seconds = end.tv_sec - start.tv_sec - (empty_loop_end.tv_sec - empty_loop_start.tv_sec);
    long microseconds = end.tv_usec - start.tv_usec - (empty_loop_end.tv_usec - empty_loop_start.tv_usec);
    double time_spent = seconds + microseconds*1e-6;

    long double operations_per_sec = 1/(long double)time_spent * interation_number * 10;
    return operations_per_sec;
}

void draw_table_line(char *operation, char *type_, double long operation_in_sec, long double max_oper_in_sec)
{
  unsigned int persentage = (unsigned int)((operation_in_sec/max_oper_in_sec)*100);

  const short unsigned max_persentage_string_length = 86;
  unsigned int num_of_fillers_of_persentage_line = (unsigned int)((operation_in_sec/max_oper_in_sec)*max_persentage_string_length);
  num_of_fillers_of_persentage_line += num_of_fillers_of_persentage_line == 0;
  char persentage_string[num_of_fillers_of_persentage_line  - 1];
  for (int i = 0; i <= num_of_fillers_of_persentage_line; i++) { persentage_string[i] = 'X';}
  persentage_string[num_of_fillers_of_persentage_line - 1] =  '\0';

  printf(" %s\t%s\t\t%Le\t%-86s\t%u\%\n", operation, type_, operation_in_sec, persentage_string, persentage);
}

void draw_entire_table()
{
    double massive_d[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    float massive_f[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    long massive_l[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int massive_i[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    char massive_c[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    unsigned int div_float_iter_num = 10000;
    unsigned int mult_float_iter_num = 10000;
    unsigned int plus_float_iter_num = 40000;
    unsigned int minus_float_iter_num = 40000;

    unsigned int div_int_iter_num = 10000;
    unsigned int mult_int_iter_num = 10000;
    unsigned int plus_int_iter_num = 40000;
    unsigned int minus_int_iter_num = 40000;

    unsigned int div_char_iter_num = 10000;
    unsigned int mult_char_iter_num = 10000;
    unsigned int plus_char_iter_num = 40000;
    unsigned int minus_char_iter_num = 40000;

    unsigned int div_long_iter_num = 10000;
    unsigned int mult_long_iter_num = 10000;
    unsigned int plus_long_iter_num = 40000;
    unsigned int minus_long_iter_num = 40000;

    unsigned int div_double_iter_num = 10000;
    unsigned int mult_double_iter_num = 10000;
    unsigned int plus_double_iter_num = 40000;
    unsigned int minus_double_iter_num = 40000;

    long double d_f_oper_in_sec = division_for_float(massive_f, div_float_iter_num);
    long double m_f_oper_in_sec = multiplying_for_float(massive_f, mult_float_iter_num);
    long double a_f_oper_in_sec = adding_for_float(massive_f, plus_float_iter_num);
    long double s_f_oper_in_sec = substaction_for_float(massive_f, minus_float_iter_num);
 
    long double d_i_oper_in_sec = division_for_int(massive_i, div_int_iter_num);
    long double m_i_oper_in_sec = multiplying_for_int(massive_i, mult_int_iter_num);
    long double a_i_oper_in_sec = adding_for_int(massive_i, plus_int_iter_num);
    long double s_i_oper_in_sec = substaction_for_int(massive_i, minus_int_iter_num);

    long double d_l_oper_in_sec = division_for_long(massive_l, div_long_iter_num);
    long double m_l_oper_in_sec = multiplying_for_long(massive_l, mult_long_iter_num);
    long double a_l_oper_in_sec = adding_for_long(massive_l, plus_long_iter_num);
    long double s_l_oper_in_sec = substaction_for_long(massive_l, minus_long_iter_num);
 
    long double d_c_oper_in_sec = division_for_char(massive_c, div_char_iter_num);
    long double m_c_oper_in_sec = multiplying_for_char(massive_c, mult_char_iter_num);
    long double a_c_oper_in_sec = adding_for_char(massive_c, plus_char_iter_num);
    long double s_c_oper_in_sec = substaction_for_char(massive_c, minus_char_iter_num);

    long double d_d_oper_in_sec = division_for_double(massive_d, div_double_iter_num);
    long double m_d_oper_in_sec = multiplying_for_double(massive_d, mult_double_iter_num);
    long double a_d_oper_in_sec = adding_for_double(massive_d, plus_double_iter_num);
    long double s_d_oper_in_sec = substaction_for_double(massive_d, minus_double_iter_num);
    
    long double all_oper_num[] = {d_f_oper_in_sec, m_f_oper_in_sec, a_f_oper_in_sec, s_f_oper_in_sec,\
                             d_l_oper_in_sec, m_l_oper_in_sec, a_l_oper_in_sec, s_l_oper_in_sec,\
                             d_d_oper_in_sec, m_d_oper_in_sec, a_d_oper_in_sec, s_d_oper_in_sec,\
                             d_i_oper_in_sec, m_i_oper_in_sec, a_i_oper_in_sec, s_i_oper_in_sec,\
                             d_c_oper_in_sec, m_c_oper_in_sec, a_c_oper_in_sec, s_c_oper_in_sec};

    long double max_oper_in_sec = a_i_oper_in_sec;
    for (int i = 0; i < sizeof(all_oper_num)/sizeof(all_oper_num[0]); i++)
    {
      if (max_oper_in_sec < all_oper_num[i]) { max_oper_in_sec = all_oper_num[i]; }
    }

    draw_table_line("/", "long", d_l_oper_in_sec, max_oper_in_sec);
    draw_table_line("*", "long", m_l_oper_in_sec, max_oper_in_sec);
    draw_table_line("+", "long", a_l_oper_in_sec, max_oper_in_sec);
    draw_table_line("-", "long", s_l_oper_in_sec, max_oper_in_sec);

    draw_table_line("/", "int", d_i_oper_in_sec, max_oper_in_sec);
    draw_table_line("*", "int", m_i_oper_in_sec, max_oper_in_sec);
    draw_table_line("+", "int", a_i_oper_in_sec, max_oper_in_sec);
    draw_table_line("-", "int", s_i_oper_in_sec, max_oper_in_sec);

    draw_table_line("/", "char", d_c_oper_in_sec, max_oper_in_sec);
    draw_table_line("*", "char", m_c_oper_in_sec, max_oper_in_sec);
    draw_table_line("+", "char", a_c_oper_in_sec, max_oper_in_sec);
    draw_table_line("-", "char", s_c_oper_in_sec, max_oper_in_sec);

    draw_table_line("/", "float", d_f_oper_in_sec, max_oper_in_sec);
    draw_table_line("*", "float", m_f_oper_in_sec, max_oper_in_sec);
    draw_table_line("+", "float", a_f_oper_in_sec, max_oper_in_sec);
    draw_table_line("-", "float", s_f_oper_in_sec, max_oper_in_sec);

    draw_table_line("/", "double", d_d_oper_in_sec, max_oper_in_sec);
    draw_table_line("*", "double", m_d_oper_in_sec, max_oper_in_sec);
    draw_table_line("+", "double", a_d_oper_in_sec, max_oper_in_sec);
    draw_table_line("-", "double", s_d_oper_in_sec, max_oper_in_sec);
    

}
int main(void) {
  draw_entire_table();
return 0;
}

